let OBSERVER_ID_PREFIX = "blazor_plugin_observer__", OBSERVER_ID = 1, observerItems = new Map; function reset() { OBSERVER_ID = 0, observerItems.clear() } function getObserverItems() { return observerItems } function getObserverElementId() { return `${OBSERVER_ID_PREFIX}${OBSERVER_ID++}` } function createObserverItem(e, t, r) { let n = onEntryChange(t), o = new IntersectionObserver(n, r); return observerItems.set(t, { dotnetRef: e, observer: o, elements: [] }), observerItems.get(t) } function observeElement(e, t) { let r = observerItems.get(e); if (null == r) throw Error(`Failed to observe element for key: ${e} as the observer does not exist`); if (r.elements.some(e => e.element == t)) return console.warn(`BlazorIntersectionObserver: The element is already being observed by observer for key ${e}`), ""; let n = getObserverElementId(); return r.observer.observe(t), r.elements.push({ elementId: n, element: t }), n } function create(e, t, r) { return createObserverItem(e, t, r) } function observe(e, t, r, n) { return createObserverItem(e, t, n), observeElement(t, r) } function unobserve(e, t) { var r; let n = observerItems.get(e); if (null == n) throw Error(`Failed to unobserve element for key: ${e} as the observer does not exist`); let o = null === (r = n.elements.find(e => e.element == t)) || void 0 === r ? void 0 : r.elementId; return null == o && console.warn(`BlazorIntersectionObserver: The record does not exist for observer: ${e}`), n.observer.unobserve(t), n.elements = n.elements.filter(e => e.element != t), o } function disconnect(e) { let t = observerItems.get(e); if (null == t) throw Error(`Failed to disconnect for key: ${e} as the observer does not exist`); return t.observer.disconnect(), t.elements = [], !0 } function remove(e) { if (disconnect(e)) return observerItems.delete(e) } function toEntryObject(e) { function t(e) { return { X: e?.x ?? 0, Y: e?.y ?? 0, Width: e?.width ?? 0, Height: e?.height ?? 0, Top: e?.top ?? 0, Left: e?.left ?? 0, Bottom: e?.bottom ?? 0, Right: e?.right ?? 0 } } return { IsIntersecting: e.isIntersecting, IntersectionRatio: e.intersectionRatio, Time: e.time, BoundingClientRect: t(e.boundingClientRect), IntersectionRect: t(e.intersectionRect), RootBounds: t(e.rootBounds) } } function onEntryChange(e) { return t => { if (!observerItems.has(e)) return; let { dotnetRef: r } = observerItems.get(e), n = t.map(e => { let t = toEntryObject(e); return t }); r.invokeMethodAsync("OnCallback", e, n) } } export { OBSERVER_ID_PREFIX, create, disconnect, getObserverItems, observe, observeElement, remove, reset, unobserve };
